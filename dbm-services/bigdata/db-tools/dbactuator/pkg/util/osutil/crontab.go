/*
 * @Description: 主机 crontab 操作
 */

package osutil

import (
	"fmt"
	"math/rand"
	"os"
	"regexp"
	"strings"
	"time"

	"dbm-services/bigdata/db-tools/dbactuator/pkg/core/cst"
	"dbm-services/common/go-pubpkg/logger"

	"github.com/robfig/cron/v3"
)

// CrontabLockFile TODO
const CrontabLockFile = "/home/mysql/.crontab_lock"

// RemoveUserCrontab TODO
func RemoveUserCrontab(user string) error {
	cmd := fmt.Sprintf("crontab -u %s -r ", user)
	output, err := ExecShellCommand(false, cmd)
	if err != nil {
		logger.Info("%s. %s", output, err.Error())
		return err
	}
	return nil
}

// GetStatusCrontab TODO
func GetStatusCrontab(user string) string {
	newCrontab := make([]string, 0)
	newCrontab = append(newCrontab, fmt.Sprintf(
		"#get_status.pl: mysql monitor and report status to tnm, distribute at %s by %s", time.Now().Format(cst.TIMELAYOUT),
		user))
	newCrontab = append(newCrontab, "*/5 * * * * /home/mysql/monitor/get_status.pl 1>/dev/null 2>&1 \n")
	return strings.Join(newCrontab, "\n")
}

// RemoveSystemCrontab TODO
/**
 * @description: 删除 mysql 用户下的crontab任务
 * @receiver {string} removeKey
 * @return {*}
 */
func RemoveSystemCrontab(removeKey string) (err error) {
	var (
		crontabs    = make([]string, 0)
		output      string
		crontabList string
	)

	output, err = ListCrontb("mysql")
	if err != nil {
		return err
	}

	formerCrontab := strings.Split(output, "\n")
	logger.Info("formerCrontab:%#v \n len(formerCrontab):%d", formerCrontab, len(formerCrontab))
	for _, crontab := range formerCrontab {
		if regexp.MustCompile(`^\\s*$`).MatchString(crontab) || strings.Contains(crontab, `#.*DO NOT EDIT THIS FILE`) ||
			strings.Contains(crontab, "#.*cron installed") || strings.Contains(crontab, "#.*Cron version") ||
			strings.Contains(crontab, "#.*installed on") || strings.Contains(crontab, removeKey) {
			continue
		}
		crontabs = append(crontabs, crontab)
	}
	// return crontabs, nil
	crontabStr := strings.Join(crontabs, "\n")
	err = ExecCrontab(crontabStr)
	if err != nil {
		return err
	}
	result, err := IsCrontabKeyExist(removeKey)
	if err != nil {
		return err
	}
	if result {
		err = fmt.Errorf("remove %s failed ,pls execute %s to check it mannually", removeKey, crontabList)
		return err
	}
	return nil
}

// ListCrontb TODO
/**
 * @description:  查看user下的crontab
 * @receiver {string} user
 * @return {*}
 */
func ListCrontb(user string) (output string, err error) {
	crontabList := fmt.Sprintf("crontab -u %s -l|egrep -v ^$ || true", user)
	// "crontab -u " + user + " -l"
	output, err = ExecShellCommand(false, crontabList)
	if err != nil {
		err = fmt.Errorf("execute [%s] get an error:%w,%s", crontabList, err, output)
		if strings.Contains(output, "no crontab for") {
			return "", nil
		} else {
			return "", err
		}
	}
	return output, err
}

// AddCrontab TODO
/**
 * @description:  追加添加crontab
 * @receiver {string} crontab 表达式
 * @return {*}
 */
func AddCrontab(crontab string) error {
	output, err := ListCrontb("mysql")
	if err != nil {
		return err
	}

	crontab = output + "\n" + crontab
	err = ExecCrontab(crontab)
	if err != nil {
		return err
	}
	return nil
}

// ExecCrontab TODO
/**
 * @description: 添加crontab
 * @receiver {string} crontab 表达式
 * @return {*}
 */
func ExecCrontab(crontab string) error {
	cmd := fmt.Sprintf("echo -e '%s' | crontab - -u mysql", crontab)
	output, err := ExecShellCommand(false, cmd)
	if err != nil {
		logger.Info("%s. %s", output, err.Error())
		return err
	}
	return nil
}

// IsCrontabKeyExist TODO
/**
 * @description:  grep crontab
 * @receiver {string} key
 * @return {*}
 */
func IsCrontabKeyExist(key string) (bool, error) {
	var (
		output string
		err    error
	)
	output, err = ListCrontb("mysql")
	if err != nil {
		return false, err
	}
	if strings.Contains(output, key) {
		return true, nil
	}
	return false, nil
}

// CrontabsExist 检查存在哪些Crontab
//
//	@receiver crontabKeys
//	@return existCrontabs
//	@return err
func CrontabsExist(crontabKeys []string) (existCrontabs []string, err error) {
	output, err := ListCrontb("mysql")
	if err != nil {
		return nil, err
	}
	for _, key := range crontabKeys {
		if strings.Contains(output, key) {
			existCrontabs = append(existCrontabs, key)
		}
	}
	return
}

// ValidateCronExpr TODO
/**
 * @description: crontab 表达式检查,如果返回error != nil，则表示crontab 表达式不正确
 * @receiver {string} cronstr eg:" * * * 3 5"
 * @return {*}
 */
func ValidateCronExpr(cronstr string) (err error) {
	specParser := cron.NewParser(cron.Minute | cron.Hour | cron.Dom | cron.Month | cron.Dow)
	_, err = specParser.Parse(cronstr)
	return
}

// CleanLocalCrontab 通过 导出 -> grep -v -> 导入 的方式实现清理crontab任务
func CleanLocalCrontab() error {
	var (
		randnum            = rand.Intn(10000)
		tmpCronFile        = fmt.Sprintf("/tmp/cron_%s_%d.crd", time.Now().Format(cst.TIMELAYOUTSEQ), randnum)
		getStatusPL        = "/home/mysql/monitor/get_status.pl"
		dbBackupOld        = "/home/mysql/dbbackup/dbbackup.sh"
		dbBackupNew        = "/home/mysql/dbbackup/dbbackup.pl"
		dbBackupMulti      = "/home/mysql/dbbackup/dbbackup_main.sh"
		dbBackupXtrabackup = "/home/mysql/dbbackup/xtrabackup/xtrabackup_main.sh"
		rotateLog          = "/home/mysql/rotate_logbin/rotate_logbin.pl"
		proxyStatus        = "/home/mysql/proxy_monitor/get_proxy_status.pl"
		slaveSync          = "/home/mysql/monitor/master_slave_sync_check.pl"
		tbinlodumperStatus = "tbinlogdumper_status.pl"
		prometheus         = "prometheus"
	)
	cleanCrontabs := []string{getStatusPL, dbBackupOld, dbBackupNew, dbBackupMulti, dbBackupXtrabackup, rotateLog,
		proxyStatus, slaveSync, tbinlodumperStatus, prometheus}

	existCrontabs, err := CrontabsExist(cleanCrontabs)
	if err != nil {
		return err
	}
	// 如果不存在需要清理的crontab 直接返回成功
	if len(existCrontabs) <= 0 {
		return nil
	}
	logger.Info("还存在的Crontabs %v", existCrontabs)
	// 导出mysql用户的crontab任务，并过滤掉要清理的任务
	shellCMD := fmt.Sprintf("/usr/bin/crontab -u mysql -l")
	for _, v := range existCrontabs {
		shellCMD += fmt.Sprintf("|grep -v %s", v)
	}
	shellCMD += fmt.Sprintf(">%s 2>&1", tmpCronFile)
	output, err := ExecShellCommand(false, shellCMD)
	if err != nil {
		err = fmt.Errorf("execute [%s] get an error:%s,%s", shellCMD, output, err.Error())
		logger.Warn(err.Error())
		// grep 没有找到结果也认为是失败的，这个地方不能当做错误返回。
	}
	// 重新导入crontab文件
	shellCMD = fmt.Sprintf("/usr/bin/crontab -u mysql %s 2>&1", tmpCronFile)
	output, err = ExecShellCommand(false, shellCMD)
	if err != nil {
		err = fmt.Errorf("execute [%s] get an error:%s", shellCMD, output)
		logger.Error(err.Error())
		return err
	}
	// crontab延时1分钟，所以直接删掉监控执行文件，保证监控执行不成功，就不会有告警了
	if err := os.RemoveAll(getStatusPL); err != nil {
		err = fmt.Errorf("rm %s failed, err:%s", getStatusPL, err.Error())
		logger.Error(err.Error())
		return err
	}
	return nil
}
